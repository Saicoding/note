```js
    [class.selected]="hero === selectedHero"
```

```js
    @Input() hero: Hero;
    <hero-detail [hero]="selectedHero"></hero-detail>  
    声明一个输入属性，hero-detail标签内可以使用hero的属性
```

```js
    switchMap((params: ParamMap) => this.heroService.getHero(+params.get('id'))) 而路由参数的值总是字符串。 所以我们需要通过 JavaScript 的 (+) 操作符把路由参数的值转成数字。
```

```js 
    return this.getHeroes()
             .then(heroes => heroes.find(hero => hero.id === id));
```

```js
    const url = `${this.heroesUrl}/${id}`; 通过id获取英雄
```

```js
    this.heroService.update(this.hero)
    .then(() => this.goBack()); 对英雄名字的修改，然后导航回前一个视图
```

```js
    <label>Hero name:</label> <input #heroName />
        <button (click)="add(heroName.value); heroName.value=''">Add
        </button>
```

```js 
    private searchTerms = new Subject<string>();
```

```js
   <input #heroInput> {{heroInput.value}}
```

```js
    <input [value]="currentHero.name"
       (input)="currentHero.name=$event.target.value" >  input 也是一个事件，就像(click)
```

```js
   <input
   [ngModel]="currentHero.name"
   (ngModelChange)="setUppercaseName($event)">
```

```js
    <div>{{currentHero | json}}</div> json管道对调试绑定特别有用
```

```js
    this._name = (name && name.trim()) || '<no name set>';会trim掉名字里的空格，并把空值替换成默认字符串。
```

```js
    template: `
    <h3>Countdown to Liftoff (via local variable)</h3>
    <button (click)="timer.start()">Start</button>
    <button (click)="timer.stop()">Stop</button>
    <div class="seconds">{{timer.seconds}}</div>
    <app-countdown-timer #timer></app-countdown-timer>
    `, 父组件与子组件通过本地变量互动
```

```js
 @Input() set appUnless(condition: boolean) {
    if (!condition && !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (condition && this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  } 注意算法：appUnless值一旦发生改变就会自动设置
```

```js
    get format()   { return this.toggle ? 'shortDate' : 'fullDate'; }
    toggleFormat() { this.toggle = !this.toggle; }
```

```js
    (keyup.enter)="addHero(box.value); box.value=''"
```

```js
    onKey(event: KeyboardEvent) { // with type info
    this.values += (<HTMLInputElement>event.target).value + ' | ';
  }
```

```js
    <input #box (keyup)="0">
    <p>{{box.value}}</p>除非你绑定一个事件，否则这将完全无法工作。
只有在应用做了些异步事件（如击键），Angular 才更新绑定（并最终影响到屏幕）。本例代码将keyup事件绑定到了数字0，这是可能是最短的模板语句。 虽然这个语句不做什么，但它满足 Angular 的要求，所以 Angular 将更新屏幕。
```

```js
//模板内容
<p *ngFor='let item of todos' #name>{{ item.name }}</p>
 
//组件中获取DOM
@ViewChildren('name')
todoNames: QueryList<ElementRef>;
 
@ViewChild('name')
todoName: ElementRef;
ngAfterViewInit(){
 this.todoNames.forEach(e=>console.log(e.nativeElement.innerText));
 console.log(this.todoName.nativeElement.innerText);
}
```

```js
this.todoNames.changes.subscribe(data => data._results.forEach(
 e=>console.log(e.nativeElement.innerText)));
this.todoNames.notifyOnChanges();
```

```js
<button type="button" class="btn btn-default" (click)="newHero(); heroForm.reset()">New Hero</button>
```

```js
<form [formGroup]="heroForm" novalidate></form>
<form>元素上的novalidate属性会阻止浏览器使用原生HTML中的表单验证器。
```

```js
<div *ngIf="password.hasError('required') && password.touched" class="error-message">* 请输入密码</div>
```

```js
logNameChange() {
  const nameControl = this.heroForm.get('name');
  nameControl.valueChanges.forEach(
    (value: string) => this.nameChangeLog.push(value)
  );当用户修改英雄的名字或秘密小屋时，Angular并不会调用ngOnChanges。 幸运的是，我们可以通过订阅表单控件的属性之一来了解这些变化，此属性会发出变更通知。
}
```